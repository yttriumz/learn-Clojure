#!/usr/bin/env bb

;; Babashka pods introduce a way to interact with external processes
;; by calling Clojure functions,
;; so that you can write code that looks and feels like Clojure (because it is)
;; even when working with a process that’s running outside your Clojure application,
;; and even when that process is written in another language.

;; ================================
;; Pod usage
;; ================================

;; Suppose you want to encrypt your dream journal.
;; You find out about stash,
;; "a command line program for storing text data in encrypted form."
;; This is exactly what you need!
;; Except it’s written in Haskell,
;; and furthermore it has a terminal user interface (TUI)
;; rather than a command-line interface.

;; That is, when you run stash from the command line
;; it "draws" an ascii interface in your terminal,
;; and you must provide additional input to store text.
;; You can’t store text directly from the command line with something like
;;
;; stash store dreams.stash \
;;       --key 20221210092035 \
;;       --value "was worried that something was wrong with the house's foundation,
;;                then the whole thing fell into a sinkhole that kept growing until
;;                it swallowed the whole neighborhood"

;; If that were possible, then you could use stash from within your Bashka project
;; by using the babashka.process/shell function, like this:
;;
;; (require '[babashka.process :as bp])
;; (bp/shell "stash store dreams.stash --key 20221210092035 --value \"...\"")

;; bp/shell is lets you take advantage of a program’s command-line interface;
;; but again, stash doesn’t provide that.

;; However, stash provides a pod interface,
;; so we can use it like this in a Clojure file:
(require '[babashka.pods :as pods])
(pods/load-pod 'rorokimdim/stash "0.3.1")
(require '[pod.rorokimdim.stash :as stash])

(stash/init {"encryption-key" "foo"
             "stash-path" "foo.stash"
             "create-stash-if-missing" true})

(stash/set 20221210092035 "dream entry")
;; Let’s start at the last line, (stash/set 20221210092035 "dream entry").
;; This is the point of pods:
;; they expose an external process’s commands as Clojure functions.
;; They allow these processes to have a Clojure interface
;; so that you can interact with them by writing Clojure code,
;; as opposed to having to shell out or make HTTP calls or something like that.

;; ================================
;; Pod implementation
;; ================================

;; Where does the stash/set function come from?
;; Both the namespace pod.rorokimdim.stash
;; and the functions in it are dynamically generated by the call
;; (pods/load-pod 'rorokimdim/stash "0.3.1").

;; For this to be possible,
;; the external program has to be written to support the pod protocol.
;; "Protocol" here does not refer to a Clojure protocol,
;; it refers to a standard for exchanging information.
;; Your Clojure application and the external application
;; need to have some way to communicate with each other
;; given that they don’t live in the same process
;; and they could even be written in different languages.

;; By implementing the pod protocol, a program becomes a pod.
;; In doing so, it gains the ability to tell the client Clojure application
;; what namespaces and functions it has available.
;; When the client application calls those functions,
;; it encodes data and sends it to the pod as a message.
;; The pod will be written such that it can listen to those messages,
;; decode them, execute the desired command internally,
;; and send a response message to the client.
